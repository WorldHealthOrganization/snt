% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1-pd-tidy-eval.r
\name{tidyeval}
\alias{tidyeval}
\alias{enquo}
\alias{enquos}
\alias{.data}
\alias{:=}
\alias{as_name}
\alias{as_label}
\title{Tidy eval helpers}
\description{
This page lists the tidy eval tools reexported in this package from
rlang. To learn about using tidy eval in scripts and packages at a
high level, see the \href{https://dplyr.tidyverse.org/articles/programming.html}{dplyr programming vignette}
and the \href{https://ggplot2.tidyverse.org/articles/ggplot2-in-packages.html}{ggplot2 in packages vignette}.
The \href{https://adv-r.hadley.nz/metaprogramming.html}{Metaprogramming section} of \href{https://adv-r.hadley.nz}{Advanced R} may also be useful for a deeper dive.
\itemize{
\item The tidy eval operators \verb{\{\{}, \verb{!!}, and \verb{!!!} are syntactic
constructs which are specially interpreted by tidy eval functions.
You will mostly need \verb{\{\{}, as \verb{!!} and \verb{!!!} are more advanced
operators which you should not have to use in simple cases.

The curly-curly operator \verb{\{\{} allows you to tunnel data-variables
passed from function arguments inside other tidy eval functions.
\verb{\{\{} is designed for individual arguments. To pass multiple
arguments contained in dots, use \code{...} in the normal way.

\if{html}{\out{<div class="sourceCode">}}\preformatted{my_function <- function(data, var, ...)
}\if{html}{\out{</div>}}
}

{
data |>
group_by(...) |>
summarise(mean = mean({{ var }}))
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{
* [enquo()] and [enquos()] delay the execution of one or several
function arguments. The former returns a single expression, the
latter returns a list of expressions. Once defused, expressions
will no longer evaluate on their own. They must be injected back
into an evaluation context with `!!` (for a single expression) and
`!!!` (for a list of expressions).

}\if{html}{\out{</div>}}

my_function <- function(data, var, ...)
{
# Defuse
var <- enquo(var)
dots <- enquos(...)

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Inject
data |>
  group_by(!!!dots) |>
  summarise(mean = mean(!!var))
}\if{html}{\out{</div>}}

}

\if{html}{\out{<div class="sourceCode">}}\preformatted{
In this simple case, the code is equivalent to the usage of `\{\{`
and `...` above. Defusing with `enquo()` or `enquos()` is only
needed in more complex cases, for instance if you need to inspect
or modify the expressions in some way.

* The `.data` pronoun is an object that represents the current
slice of data. If you have a variable name in a string, use the
`.data` pronoun to subset that variable with `[[`.

}\if{html}{\out{</div>}}

my_var <- 'disp'
mtcars |> summarise(mean = mean(.data[[my_var]]))

\if{html}{\out{<div class="sourceCode">}}\preformatted{
* Another tidy eval operator is `:=`. It makes it possible to use
glue and curly-curly syntax on the LHS of `=`. For technical
reasons, the R language doesn't support complex expressions on
the left of `=`, so we use `:=` as a workaround.

}\if{html}{\out{</div>}}

my_function <- function(data, var, suffix = 'foo')
{
# Use \verb{\{\{} to tunnel function arguments and the usual glue
# operator \verb{\{} to interpolate plain strings.
data |>
summarise('{{ var }}\emph{mean}{suffix}' := mean({{ var }}))
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{
* Many tidy eval functions like `dplyr::mutate()` or
`dplyr::summarise()` give an automatic name to unnamed inputs. If
you need to create the same sort of automatic names by yourself,
use `as_label()`. For instance, the glue-tunnelling syntax above
can be reproduced manually with:

}\if{html}{\out{</div>}}

my_function <- function(data, var, suffix = 'foo')
{
var <- enquo(var)
prefix <- as_label(var)
data |>
summarise('{prefix}\emph{mean}{suffix}' := mean(!!var))
}

\if{html}{\out{<div class="sourceCode">}}\preformatted{
Expressions defused with `enquo()` (or tunnelled with `\{\{`) need
not be simple column names, they can be arbitrarily complex.
`as_label()` handles those cases gracefully. If your code assumes
a simple column name, use `as_name()` instead. This is safer
because it throws an error if the input is not a name as expected.


[dplyr programming
vignette]: R:dplyr\%20programming\%0Avignette
[ggplot2 in packages
vignette]: R:ggplot2\%20in\%20packages\%0Avignette
[Metaprogramming
section]: R:Metaprogramming\%0Asection
[Advanced
R]: R:Advanced\%0AR
[enquo()]: R:enquo()
[enquos()]: R:enquos()
[my_var]: R:my_var
}\if{html}{\out{</div>}}
}
\keyword{internal}
