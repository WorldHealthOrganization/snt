#' Calculate the expected reports
#' 
expected <- function(df) {
    target_list <- df |>
    select(!!!args) |>
    unique()


  min_year <- min(df$year)
  max_year <- max(df$year)
  year <- tibble(year = min_year:max_year)
  month <- tibble(month = 1:12)
  target_list_ym <- target_list |>
    cross_join(year) |>
    cross_join(month)
  exp <- target_list_ym |>
    mutate(
      exp = 1
    )
    return(exp)
}

#' Calculate the reporting rate for each indicator
#' 
#' For each indicator, calculate the reporting rate for each year and month
#' The reporting rate is calculated as the number of reports divided by the
#' number of expected reports. Here, the expected reports are calculated as
#' the number of unique combinations of the provided columns, multiplied by
#' the number of months and years in the data.
#' So in this function, the data is first grouped by the provided columns,
#' and then the number of unique combinations is calculated. Then, the data
#' is expanded to include all combinations of the provided columns, years,
#' and months. Then, the number of expected reports is calculated as the
#' number of unique combinations multiplied by the number of months and years.
#' Finally, the number of reports is calculated as the sum of the reports
#' for each combination of the provided columns, years, and months.
#' 
#' @param df A data frame
#' @param ... Columns to calculate the reporting rate, excluding year and month
#' @return Dataframe
#' @import dplyr
#' @importFrom rlang enquos
#' @importFrom tibble tibble
#' @export
report_rate <- function(df, ...) {
  args <- enquos(...)
  rep <- df |>
    mutate(
      rep = if_else(rowSums(
        across(
          !c(!!!args, year, month) & where(is.numeric)
        ),
        na.rm = TRUE
      ) == 0, 0, 1)
    ) |>
    select(
      !!!args, year, month,
      rep
    )

  reprate <- exp |>
    left_join(rep) |>
    # filling NA with 0
    mutate(
      rep = if_else(is.na(rep), 0, rep)
    )

  reprate |>
    group_by(!!!args) |>
    summarize(
      exp = sum(exp),
      rep = sum(rep)
    ) |>
    mutate(
      reprat = rep / exp
    )
}

#' Calculate the report status
#'
#' If any indicator is reported, the report status is "Y", otherwise "N"
#' grouped by the provided columns
#' @param df A data frame
#' @param ... Columns to group by
#' @return Dataframe
#' @import dplyr
#' @importFrom rlang enquos .data
#' @export
report_status <- function(df, ...) {
  # create a list of arguments
  args <- enquos(...)
  # group data frame by arguments
  df <- df |>
    group_by(!!!args) |>
    # calculate sum for each group for all numeric columns
    summarise(
      across(
        !any_of(c("year", "month")) &
          where(is.numeric),
        ~ sum(.x, na.rm = TRUE)
      )
    ) |>
    # ungroup data frame
    ungroup()


  df <- df |>
        mutate(
          reported = if_else(rowSums(
            across(
              !any_of(c("year", "month")) & !c(!!!args) & where(is.numeric) 
            ),
            na.rm = TRUE
          ) == 0, 0, 1)
        )
 
  # select only arguments and reported column
  df |>
    select(
      !!!args, "reported"
    ) |>
    # convert reported to character
    mutate(
      reported = if_else(.data$reported > 0, "Y", "N")
    )
}

#' Calculate the report duration
#' Get the min max report year and month for each group based on the report status
#' This code filters the data by the reported column to only include data
#' that is reported, then groups the data by the variables specified in the
#' function call. It then calculates the min and max year and month for each
#' group, and then filters out any groups that have NA for the min year.
#' @param df A data frame with report status generated by report_status()
#' @param ... Columns to group by
#' @return Dataframe
#' @import dplyr
#' @importFrom rlang enquos
#' @export
get_report_duration <- function(df, ...) {
  args <- enquos(...)
  report_duration <- df |>
    filter(.data$reported == "Y") |>
    group_by(!!!args) |>
    summarise(
      min_year = min(.data$year, na.rm = TRUE),
      min_month = min(.data$month, na.rm = TRUE),
      max_year = max(.data$year, na.rm = TRUE),
      max_month = max(.data$month, na.rm = TRUE)
    ) |>
    ungroup() |>
    mutate(
      min_year = as.integer(.data$min_year),
      min_month = as.integer(.data$min_month),
      max_year = as.integer(.data$max_year),
      max_month = as.integer(.data$max_month)
    )
  # need the full list of groups
  df |>
    select(!!!args) |>
    distinct(!!!args) |>
    left_join(report_duration)
}
